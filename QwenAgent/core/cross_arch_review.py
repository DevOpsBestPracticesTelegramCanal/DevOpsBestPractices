"""
Cross-Architecture Review — Claude Haiku reviews code generated by local Qwen model.

Advisory only: surfaces issues as warnings, never triggers re-generation.
Graceful degradation: if anthropic package is missing or no API key, feature is silently disabled.

Components:
    - ReviewSeverity / ReviewIssue / ReviewResult — data classes
    - CircuitBreaker — 3 failures → OPEN for 5 min → HALF_OPEN probe
    - CostTracker — monthly budget cap (default $5/month)
    - CrossArchReviewer — main entry point
"""

import json
import logging
import threading
import time
from dataclasses import dataclass, field
from enum import Enum
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Try to import anthropic — if missing, module still loads but reviewer is disabled
# ---------------------------------------------------------------------------
try:
    import anthropic
    HAS_ANTHROPIC = True
except ImportError:
    HAS_ANTHROPIC = False
    anthropic = None  # type: ignore


# ---------------------------------------------------------------------------
# Data classes
# ---------------------------------------------------------------------------

class ReviewSeverity(Enum):
    CRITICAL = "critical"
    WARNING = "warning"
    INFO = "info"


@dataclass
class ReviewIssue:
    severity: ReviewSeverity
    category: str  # e.g. "security", "performance", "correctness"
    description: str
    line: Optional[int] = None
    suggestion: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "severity": self.severity.value,
            "category": self.category,
            "description": self.description,
            "line": self.line,
            "suggestion": self.suggestion,
        }


@dataclass
class ReviewResult:
    issues: List[ReviewIssue] = field(default_factory=list)
    model: str = ""
    cost_usd: float = 0.0
    input_tokens: int = 0
    output_tokens: int = 0
    skipped: bool = False
    skip_reason: str = ""

    @property
    def has_critical(self) -> bool:
        return any(i.severity == ReviewSeverity.CRITICAL for i in self.issues)

    def summary(self) -> str:
        if self.skipped:
            return f"Review skipped: {self.skip_reason}"
        n = len(self.issues)
        crits = sum(1 for i in self.issues if i.severity == ReviewSeverity.CRITICAL)
        warns = sum(1 for i in self.issues if i.severity == ReviewSeverity.WARNING)
        infos = n - crits - warns
        return (
            f"{n} issues ({crits} critical, {warns} warning, {infos} info) "
            f"| model={self.model} cost=${self.cost_usd:.4f}"
        )

    def to_dict(self) -> Dict[str, Any]:
        return {
            "issues": [i.to_dict() for i in self.issues],
            "model": self.model,
            "cost_usd": round(self.cost_usd, 6),
            "input_tokens": self.input_tokens,
            "output_tokens": self.output_tokens,
            "has_critical": self.has_critical,
            "skipped": self.skipped,
            "skip_reason": self.skip_reason,
            "summary": self.summary(),
        }


# ---------------------------------------------------------------------------
# Circuit Breaker
# ---------------------------------------------------------------------------

class CircuitState(Enum):
    CLOSED = "closed"
    OPEN = "open"
    HALF_OPEN = "half_open"


class CircuitBreaker:
    """
    Simple circuit breaker: 3 consecutive failures → OPEN for cooldown_sec.
    After cooldown, transitions to HALF_OPEN; one success → CLOSED, one failure → OPEN.
    """

    def __init__(self, failure_threshold: int = 3, cooldown_sec: float = 300.0):
        self.failure_threshold = failure_threshold
        self.cooldown_sec = cooldown_sec
        self._state = CircuitState.CLOSED
        self._failure_count = 0
        self._last_failure_time = 0.0
        self._lock = threading.Lock()

    @property
    def state(self) -> CircuitState:
        with self._lock:
            if self._state == CircuitState.OPEN:
                if time.time() - self._last_failure_time >= self.cooldown_sec:
                    self._state = CircuitState.HALF_OPEN
            return self._state

    def allow_request(self) -> bool:
        s = self.state
        return s in (CircuitState.CLOSED, CircuitState.HALF_OPEN)

    def record_success(self):
        with self._lock:
            self._state = CircuitState.CLOSED
            self._failure_count = 0

    def record_failure(self):
        with self._lock:
            self._failure_count += 1
            self._last_failure_time = time.time()
            if self._failure_count >= self.failure_threshold:
                self._state = CircuitState.OPEN

    def reset(self):
        with self._lock:
            self._state = CircuitState.CLOSED
            self._failure_count = 0
            self._last_failure_time = 0.0


# ---------------------------------------------------------------------------
# Cost Tracker
# ---------------------------------------------------------------------------

class CostTracker:
    """Track API costs with a monthly budget cap."""

    # Haiku pricing (per 1M tokens) — as of 2025
    HAIKU_INPUT_COST = 0.25 / 1_000_000
    HAIKU_OUTPUT_COST = 1.25 / 1_000_000

    def __init__(self, monthly_budget: float = 5.0):
        self.monthly_budget = monthly_budget
        self._total_cost = 0.0
        self._month_start = self._current_month()
        self._lock = threading.Lock()

    @staticmethod
    def _current_month() -> str:
        import datetime
        return datetime.datetime.now().strftime("%Y-%m")

    def _maybe_reset(self):
        current = self._current_month()
        if current != self._month_start:
            self._total_cost = 0.0
            self._month_start = current

    def has_budget(self) -> bool:
        with self._lock:
            self._maybe_reset()
            return self._total_cost < self.monthly_budget

    def record(self, input_tokens: int, output_tokens: int) -> float:
        cost = (
            input_tokens * self.HAIKU_INPUT_COST
            + output_tokens * self.HAIKU_OUTPUT_COST
        )
        with self._lock:
            self._maybe_reset()
            self._total_cost += cost
        return cost

    @property
    def total_cost(self) -> float:
        with self._lock:
            self._maybe_reset()
            return self._total_cost

    @property
    def remaining_budget(self) -> float:
        with self._lock:
            self._maybe_reset()
            return max(0.0, self.monthly_budget - self._total_cost)


# ---------------------------------------------------------------------------
# Cross-Architecture Reviewer
# ---------------------------------------------------------------------------

# SWECAS codes that warrant review: Security (500), Infrastructure (900), Performance (700)
_REVIEW_SWECAS = {500, 501, 502, 503, 504, 505, 700, 701, 702, 900, 901, 902, 903}

_SYSTEM_PROMPT = """\
You are a senior code reviewer. You review code generated by a local 7B-parameter LLM.
Your job is to find bugs, security issues, performance problems, and correctness issues.

Respond with a JSON array of issues. Each issue object has:
- "severity": "critical" | "warning" | "info"
- "category": one of "security", "correctness", "performance", "style", "robustness"
- "description": concise explanation of the issue
- "line": line number (integer, 1-based) or null
- "suggestion": how to fix it, or null

If the code looks correct, return an empty array: []

IMPORTANT: Return ONLY the JSON array, no markdown fences, no extra text.
"""


class CrossArchReviewer:
    """
    Reviews code via Claude Haiku API. Advisory only — issues are surfaced as warnings.

    Graceful degradation:
        - No `anthropic` package → disabled
        - No API key → disabled
        - Circuit breaker open → skipped
        - Budget exhausted → skipped
    """

    MODEL = "claude-haiku-4-5-20251001"

    def __init__(
        self,
        api_key: Optional[str] = None,
        monthly_budget: float = 5.0,
        enabled: bool = True,
    ):
        self._enabled = enabled and HAS_ANTHROPIC and bool(api_key)
        self._client = None
        if self._enabled:
            self._client = anthropic.Anthropic(api_key=api_key)

        self.circuit_breaker = CircuitBreaker(failure_threshold=3, cooldown_sec=300.0)
        self.cost_tracker = CostTracker(monthly_budget=monthly_budget)

        # Stats
        self._review_count = 0
        self._issues_found = 0
        self._lock = threading.Lock()

    @property
    def enabled(self) -> bool:
        return self._enabled

    def should_review(
        self,
        swecas_code: Optional[int] = None,
        code: Optional[str] = None,
        force: bool = False,
    ) -> bool:
        """Decide whether to review this code."""
        if not self._enabled:
            return False
        if not self.circuit_breaker.allow_request():
            return False
        if not self.cost_tracker.has_budget():
            return False
        if force:
            return True
        # Review security/infra/performance SWECAS codes
        if swecas_code and swecas_code in _REVIEW_SWECAS:
            return True
        # Review long code (heuristic: >50 lines likely important)
        if code and len(code.strip().splitlines()) > 50:
            return True
        return False

    def review(
        self,
        code: str,
        validation_summary: str = "",
        query: str = "",
        swecas_code: Optional[int] = None,
    ) -> ReviewResult:
        """Send code to Claude Haiku for review. Returns ReviewResult."""
        if not self._enabled:
            return ReviewResult(skipped=True, skip_reason="reviewer disabled")

        if not self.circuit_breaker.allow_request():
            return ReviewResult(skipped=True, skip_reason="circuit breaker open")

        if not self.cost_tracker.has_budget():
            return ReviewResult(skipped=True, skip_reason="monthly budget exhausted")

        prompt = self._build_review_prompt(code, validation_summary, query, swecas_code)

        try:
            response = self._client.messages.create(
                model=self.MODEL,
                max_tokens=1024,
                system=_SYSTEM_PROMPT,
                messages=[{"role": "user", "content": prompt}],
            )

            # Extract usage
            input_tokens = response.usage.input_tokens
            output_tokens = response.usage.output_tokens
            cost = self.cost_tracker.record(input_tokens, output_tokens)

            # Parse response
            text = response.content[0].text if response.content else "[]"
            issues = self._parse_review_response(text)

            self.circuit_breaker.record_success()

            with self._lock:
                self._review_count += 1
                self._issues_found += len(issues)

            return ReviewResult(
                issues=issues,
                model=self.MODEL,
                cost_usd=cost,
                input_tokens=input_tokens,
                output_tokens=output_tokens,
            )

        except Exception as e:
            logger.warning("[CrossArchReview] API error: %s", e)
            self.circuit_breaker.record_failure()
            return ReviewResult(skipped=True, skip_reason=f"API error: {e}")

    def _build_review_prompt(
        self,
        code: str,
        validation_summary: str,
        query: str,
        swecas_code: Optional[int],
    ) -> str:
        parts = []
        if query:
            parts.append(f"Task: {query}")
        if swecas_code:
            parts.append(f"SWECAS code: {swecas_code}")
        if validation_summary:
            parts.append(f"Local validation: {validation_summary}")
        parts.append(f"\nCode to review:\n```\n{code}\n```")
        return "\n".join(parts)

    @staticmethod
    def _parse_review_response(text: str) -> List[ReviewIssue]:
        """Parse JSON array from Claude response, handling markdown fences."""
        # Strip markdown code fences if present
        cleaned = text.strip()
        if cleaned.startswith("```"):
            lines = cleaned.split("\n")
            # Remove first and last fence lines
            if len(lines) >= 2:
                cleaned = "\n".join(lines[1:-1] if lines[-1].strip() == "```" else lines[1:])
                cleaned = cleaned.strip()

        try:
            data = json.loads(cleaned)
        except (json.JSONDecodeError, ValueError):
            logger.warning("[CrossArchReview] Failed to parse response as JSON")
            return []

        if not isinstance(data, list):
            return []

        issues = []
        for item in data:
            if not isinstance(item, dict):
                continue
            try:
                severity = ReviewSeverity(item.get("severity", "info"))
            except ValueError:
                severity = ReviewSeverity.INFO

            issues.append(ReviewIssue(
                severity=severity,
                category=item.get("category", "general"),
                description=item.get("description", ""),
                line=item.get("line"),
                suggestion=item.get("suggestion"),
            ))

        return issues

    def get_stats(self) -> Dict[str, Any]:
        with self._lock:
            return {
                "enabled": self._enabled,
                "review_count": self._review_count,
                "issues_found": self._issues_found,
                "total_cost_usd": round(self.cost_tracker.total_cost, 4),
                "remaining_budget": round(self.cost_tracker.remaining_budget, 4),
                "circuit_breaker_state": self.circuit_breaker.state.value,
            }
