<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QwenCode</title>
    <link rel="manifest" href="/static/manifest.json">
    <meta name="theme-color" content="#0d1117">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="apple-touch-icon" href="/static/icon-192.png">
    <link rel="icon" type="image/png" href="/static/icon-192.png">
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    <link rel="stylesheet" href="/static/css/qwencode.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <style>
        /* Minimal overrides - main styles in /static/css/qwencode.css */

        /* SearchDeep mode selector */
        .searchdeep-select {
            background: var(--bg-secondary);
            color: var(--text-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            display: none;
        }
        .searchdeep-select:focus {
            outline: none;
            border-color: var(--accent-orange);
        }
        .searchdeep-select.visible {
            display: block;
        }

        /* SWECAS classification tag */
        .swecas-tag {
            margin-top: 12px;
            padding: 8px 12px;
            background: linear-gradient(135deg, rgba(163, 113, 247, 0.1), rgba(88, 166, 255, 0.1));
            border: 1px solid var(--accent-purple);
            border-radius: 6px;
            font-size: 12px;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .swecas-badge {
            background: var(--gradient-primary);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 11px;
        }

        /* Collapsible sections */
        .collapsible.collapsed .collapsible-content { display: none; }
        .collapsible.collapsed .collapsed-preview { display: block; }
        .collapsed-preview {
            display: none;
            color: var(--text-muted);
            font-size: 12px;
            padding: 8px 14px;
            background: var(--glass-bg-light);
            border-top: 1px dashed var(--glass-border);
            cursor: pointer;
        }
        .collapsed-preview:hover {
            background: var(--glass-bg);
            color: var(--text-secondary);
        }
        .collapsed-preview .expand-hint {
            color: var(--accent-blue);
            margin-left: 8px;
        }
        .expand-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 4px 8px;
            font-size: 11px;
            border-radius: 4px;
            transition: var(--transition-fast);
        }
        .expand-btn:hover {
            background: var(--glass-bg-light);
            color: var(--text-primary);
        }
        .expand-btn .arrow {
            display: inline-block;
            transition: transform 0.2s;
            margin-right: 4px;
        }
        .collapsible.collapsed .expand-btn .arrow { transform: rotate(-90deg); }

        /* Collapsed tool result */
        .tool-result.collapsed-content {
            max-height: 0;
            padding: 0 14px;
            overflow: hidden;
            transition: max-height 0.2s, padding 0.2s;
        }
        .collapsible:not(.collapsed) .tool-result.collapsed-content {
            max-height: 400px;
            padding: 12px 14px;
        }
        .collapse-summary {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 14px;
            font-size: 12px;
            color: var(--text-muted);
            background: var(--glass-bg-light);
            cursor: pointer;
        }
        .collapse-summary:hover { background: var(--glass-bg); }
        .collapse-summary .line-count { color: var(--accent-cyan); }

        /* Markdown tables */
        .md-table {
            border-collapse: collapse;
            width: 100%;
            margin: 12px 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }
        .md-table th {
            background: var(--glass-bg-light);
            border: 1px solid var(--glass-border);
            padding: 8px 12px;
            text-align: left;
            color: var(--accent-cyan);
            font-weight: 600;
        }
        .md-table td {
            border: 1px solid var(--glass-border);
            padding: 8px 12px;
            color: var(--text-primary);
        }
        .md-table tr:nth-child(even) { background: var(--glass-bg); }
        .md-table tr:hover { background: var(--glass-bg-light); }

        /* Choice container (Claude Code style) */
        .choice-container {
            margin: 16px 0;
            padding: 16px;
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            background: var(--glass-bg);
            backdrop-filter: blur(var(--glass-blur-sm));
        }
        .choice-context {
            color: var(--text-primary);
            font-weight: 500;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--glass-border);
        }
        .choice-options {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .choice-option {
            padding: 10px 14px;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: 8px;
            transition: var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
        }
        .choice-option:hover {
            background: var(--glass-bg-light);
            color: var(--text-primary);
        }
        .choice-option.choice-selected {
            background: rgba(88, 166, 255, 0.15);
            color: var(--accent-blue);
            border: 1px solid rgba(88, 166, 255, 0.3);
        }
        .choice-key {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 24px;
            height: 24px;
            background: var(--glass-bg-light);
            border: 1px solid var(--glass-border);
            border-radius: 6px;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
        }
        .choice-option:hover .choice-key,
        .choice-option.choice-selected .choice-key {
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }
        .choice-input-area {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--glass-border);
        }
        .choice-input-area textarea {
            width: 100%;
            min-height: 60px;
            background: var(--bg-input);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            padding: 10px 12px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 13px;
            resize: vertical;
            outline: none;
        }
        .choice-input-area textarea:focus {
            border-color: var(--accent-purple);
            box-shadow: var(--shadow-glow-purple);
        }
        .choice-buttons {
            display: flex;
            gap: 8px;
            margin-top: 10px;
            justify-content: flex-end;
        }

        /* Code block with line numbers */
        .code-block-content {
            background: var(--code-bg);
            border: 1px solid var(--glass-border);
            border-radius: 0 0 12px 12px;
            overflow-x: auto;
            max-height: 500px;
            overflow-y: auto;
        }
        .code-line {
            display: flex;
            flex-direction: row;
            align-items: stretch;
            line-height: 1.7;
            min-height: 24px;
        }
        .code-line:hover { background: rgba(255, 255, 255, 0.03); }
        .code-line-number {
            width: 48px;
            min-width: 48px;
            color: var(--text-muted);
            text-align: right;
            padding: 0 12px 0 8px;
            user-select: none;
            background: rgba(0, 0, 0, 0.25);
            font-size: 12px;
            border-right: 1px solid var(--glass-border);
            font-family: 'JetBrains Mono', monospace;
            flex-shrink: 0;
        }
        .code-line-content {
            flex: 1;
            padding: 0 14px;
            white-space: pre;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
        }

        /* Message body formatting */
        .message-body p { margin: 8px 0; }
        .message-body ul, .message-body ol { margin: 8px 0; padding-left: 24px; }
        .message-body li { margin: 4px 0; }
        .message-content {
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            line-height: 1.6;
        }

        /* Thinking block enhancements */
        .thinking-block .thinking-header {
            cursor: pointer;
            padding: 12px 14px;
        }
        .thinking-block .thinking-header:hover {
            background: rgba(163, 113, 247, 0.15);
        }
        .thinking-block .line-count {
            color: var(--text-muted);
            font-weight: normal;
            font-size: 12px;
        }
        .thinking-block .expand-hint {
            color: var(--accent-blue);
            font-weight: normal;
            font-size: 11px;
            margin-left: auto;
        }
        .thinking-block.collapsed .collapsible-content { display: none; }
        .thinking-block .thinking-content {
            padding: 0 14px 14px 14px;
            white-space: pre-wrap;
        }

        /* AI Search mode */
        .mode-btn.active.aisearch {
            background: var(--gradient-warning);
            box-shadow: var(--shadow-glow-orange);
        }
        .mode-banner.aisearch {
            background: linear-gradient(90deg, rgba(247, 129, 102, 0.12), transparent);
            border-color: rgba(247, 129, 102, 0.25);
            color: var(--accent-orange);
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">
            <div class="logo-icon">Q</div>
            <div>
                <div class="logo-text">QwenCode</div>
                <div class="logo-version">v3.0.0 ‚Ä¢ Frosted Terminal Pro</div>
            </div>
        </div>
        <div class="header-controls">
            <div class="status-indicator">
                <div class="status-dot" id="status-dot"></div>
                <span id="status-text">Connected</span>
            </div>
            <div class="model-selector" id="model-selector">
                <div class="model-badge" id="model-badge" title="Click to switch model">
                    <span id="model-name">qwen2.5-coder</span>
                    <span class="model-badge-arrow">‚ñº</span>
                </div>
                <div class="model-dropdown" id="model-dropdown">
                    <div class="model-dropdown-header">Available Models</div>
                    <div id="model-list">
                        <div class="model-dropdown-loading">Loading models...</div>
                    </div>
                </div>
            </div>
            <div class="mode-selector">
                <!-- Fast Mode -->
                <div class="mode-btn-wrapper">
                    <button class="mode-btn fast active" id="mode-fast">‚ö° Fast</button>
                    <div class="mode-tooltip">
                        <div class="tooltip-title">‚ö° FAST MODE</div>
                        <div class="tooltip-desc">Pattern matching –¥–ª—è –ø—Ä–æ—Å—Ç—ã—Ö –∑–∞–¥–∞—á</div>
                        <div class="tooltip-list">
                            <div>‚Ä¢ –ß—Ç–µ–Ω–∏–µ —Ñ–∞–π–ª–æ–≤, –ø–æ–∏—Å–∫</div>
                            <div>‚Ä¢ –ü—Ä–æ—Å—Ç—ã–µ –∫–æ–º–∞–Ω–¥—ã</div>
                            <div>‚Ä¢ –ë—ã—Å—Ç—Ä—ã–µ –æ—Ç–≤–µ—Ç—ã (~1 —Å–µ–∫)</div>
                        </div>
                        <div class="tooltip-triggers">
                            <div class="tooltip-triggers-title">–¢—Ä–∏–≥–≥–µ—Ä—ã:</div>
                            <div>–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é, [FAST]</div>
                        </div>
                    </div>
                </div>

                <!-- Deep3 Mode -->
                <div class="mode-btn-wrapper">
                    <button class="mode-btn deep3" id="mode-deep3">üî¨ Deep3</button>
                    <div class="mode-tooltip">
                        <div class="tooltip-title">üî¨ DEEP3 MODE</div>
                        <div class="tooltip-desc">–£–ø—Ä–æ—â—ë–Ω–Ω—ã–π Chain-of-Thought (3 —à–∞–≥–∞)</div>
                        <div class="tooltip-list">
                            <div>‚Ä¢ Understanding ‚Üí Approaches ‚Üí Solution</div>
                            <div>‚Ä¢ –°—Ä–µ–¥–Ω—è—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å –∑–∞–¥–∞—á</div>
                            <div>‚Ä¢ –í—Ä–µ–º—è: 10-30 —Å–µ–∫</div>
                        </div>
                        <div class="tooltip-triggers">
                            <div class="tooltip-triggers-title">–¢—Ä–∏–≥–≥–µ—Ä—ã:</div>
                            <div>[DEEP3], --deep3</div>
                        </div>
                    </div>
                </div>

                <!-- Deep6 Mode -->
                <div class="mode-btn-wrapper">
                    <button class="mode-btn deep6" id="mode-deep6">üß† Deep6</button>
                    <div class="mode-tooltip">
                        <div class="tooltip-title">üß† DEEP6 MODE (Minsky)</div>
                        <div class="tooltip-model">Model: qwen2.5-coder:14b (CoT 6-step)</div>
                        <div class="tooltip-desc">–ü–æ–ª–Ω—ã–π 6-—à–∞–≥–æ–≤—ã–π –∞–Ω–∞–ª–∏–∑ –ø–æ –ú–∏–Ω—Å–∫–∏</div>
                        <div class="tooltip-list">
                            <div>‚Ä¢ Understanding ‚Üí Challenges ‚Üí Approaches</div>
                            <div>‚Ä¢ Constraints ‚Üí Choose ‚Üí Solution</div>
                            <div>‚Ä¢ –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ/–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –∑–∞–¥–∞—á–∏</div>
                            <div>‚Ä¢ –í—Ä–µ–º—è: 30-120 —Å–µ–∫</div>
                        </div>
                        <div class="tooltip-triggers">
                            <div class="tooltip-triggers-title">–¢—Ä–∏–≥–≥–µ—Ä—ã:</div>
                            <div>[DEEP], [DEEP6], --deep</div>
                        </div>
                    </div>
                </div>

                <!-- Search Mode -->
                <div class="mode-btn-wrapper">
                    <button class="mode-btn search" id="mode-search">üåê Search</button>
                    <div class="mode-tooltip tooltip-left">
                        <div class="tooltip-title">üåê SEARCH MODE</div>
                        <div class="tooltip-model">DuckDuckGo / SearXNG</div>
                        <div class="tooltip-desc">–ë—ã—Å—Ç—Ä—ã–π –ø–æ–∏—Å–∫ –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–µ</div>
                        <div class="tooltip-list">
                            <div>‚Ä¢ –ê–∫—Ç—É–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è</div>
                            <div>‚Ä¢ CVE, —Ä–µ–ª–∏–∑—ã, –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è</div>
                            <div>‚Ä¢ –ë–µ–∑ –≥–ª—É–±–æ–∫–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞</div>
                        </div>
                        <div class="tooltip-triggers">
                            <div class="tooltip-triggers-title">–¢—Ä–∏–≥–≥–µ—Ä—ã:</div>
                            <div>[SEARCH], --search</div>
                        </div>
                    </div>
                </div>

                <!-- Search+Deep Mode -->
                <div class="mode-btn-wrapper">
                    <button class="mode-btn searchdeep" id="mode-searchdeep">üîç Search+Deep</button>
                    <div class="mode-tooltip tooltip-left">
                        <div class="tooltip-title">üîç SEARCH+DEEP MODE</div>
                        <div class="tooltip-model">Search ‚Üí Deep3/Deep6 Analysis</div>
                        <div class="tooltip-desc">–ü–æ–∏—Å–∫ + –≥–ª—É–±–æ–∫–∏–π –∞–Ω–∞–ª–∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤</div>
                        <div class="tooltip-list">
                            <div>‚Ä¢ –í–µ–±-–ø–æ–∏—Å–∫ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏</div>
                            <div>‚Ä¢ –ó–∞—Ç–µ–º CoT-–∞–Ω–∞–ª–∏–∑ –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ</div>
                            <div>‚Ä¢ –í—ã–±–æ—Ä Deep3 –∏–ª–∏ Deep6 —Å–ø—Ä–∞–≤–∞ ‚Üí</div>
                        </div>
                        <div class="tooltip-triggers">
                            <div class="tooltip-triggers-title">–¢—Ä–∏–≥–≥–µ—Ä—ã:</div>
                            <div>[SEARCH+DEEP], --searchdeep</div>
                        </div>
                    </div>
                </div>

                <select id="searchdeep-mode" class="searchdeep-select" title="Analysis mode for Search+Deep">
                    <option value="deep3">‚Üí Deep3</option>
                    <option value="deep6">‚Üí Deep6</option>
                </select>
            </div>
            <button class="header-btn" id="install-btn" title="Install as desktop app">Install</button>
            <button class="header-btn" id="fullscreen-btn" title="Toggle fullscreen (F11)">&#x26F6;</button>
        </div>
    </div>

    <div class="mode-banner" id="mode-banner">
        <span id="mode-banner-icon">üß†</span>
        <span id="mode-banner-text">Deep Mode - Chain-of-Thought reasoning enabled</span>
    </div>

    <div class="terminal-container">
        <div class="output" id="output">
            <div class="message message-system">
                <strong>QwenCode Terminal</strong> ‚Äî Local AI coding assistant<br>
                Type <code>/help</code> for commands ‚Ä¢ <code>Ctrl+Enter</code> to send
            </div>
        </div>

        <div class="input-area">
            <div class="input-wrapper">
                <span class="input-prompt">‚ùØ</span>
                <textarea id="input" placeholder="Ask anything... (Shift+Enter: new line, Ctrl+O: expand sections)" rows="3"></textarea>
                <div class="input-actions">
                    <span class="shortcut-hint">Shift+‚Üµ new line ‚Ä¢ Ctrl+‚Üµ send ‚Ä¢ Ctrl+O expand</span>
                    <button class="send-btn" id="send-btn">Send</button>
                    <button class="stop-btn" id="stop-btn" title="Stop request (Esc)">‚èπ Stop</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ========== DOM ELEMENTS ==========
        const output = document.getElementById('output');
        const input = document.getElementById('input');
        const sendBtn = document.getElementById('send-btn');
        const statusDot = document.getElementById('status-dot');
        const statusText = document.getElementById('status-text');
        const modelBadge = document.getElementById('model-badge');
        const modeBanner = document.getElementById('mode-banner');
        const modeBannerIcon = document.getElementById('mode-banner-icon');
        const modeBannerText = document.getElementById('mode-banner-text');

        // Mode buttons
        const modeFast = document.getElementById('mode-fast');
        const modeDeep3 = document.getElementById('mode-deep3');
        const modeDeep6 = document.getElementById('mode-deep6');
        const modeSearch = document.getElementById('mode-search');
        const modeSearchDeep = document.getElementById('mode-searchdeep');

        // ========== STATE ==========
        let isProcessing = false;
        let currentMode = 'fast';
        let pendingConfirmation = null;
        let selectedChoiceIndex = 0;
        let abortController = null;

        // Stop button
        const stopBtn = document.getElementById('stop-btn');

        // ========== TOOL ICONS ==========
        const TOOL_ICONS = {
            'read': 'üìñ', 'write': '‚úèÔ∏è', 'edit': 'üîß', 'ls': 'üìÅ',
            'bash': 'üíª', 'grep': 'üîç', 'glob': 'üîç', 'search': 'üîç',
            'git': 'üì¶', 'web_fetch': 'üåê', 'web_search': 'üåê',
            'tree': 'üå≥', 'diff': 'üìä', 'notebook_read': 'üìì',
            'notebook_edit': 'üìì', 'default': '‚ö°'
        };

        // ========== TOOL LABELS (for live activity) ==========
        const TOOL_LABELS = {
            'read': 'Reading file',
            'write': 'Writing file',
            'edit': 'Editing file',
            'bash': 'Running command',
            'ls': 'Listing directory',
            'grep': 'Searching',
            'glob': 'Finding files',
            'git': 'Git operation',
            'tree': 'Showing tree',
            'web_fetch': 'Fetching URL',
            'web_search': 'Searching web',
            'diff': 'Comparing files'
        };

        // ========== INPUT HANDLING ==========
        input.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 300) + 'px';
        });

        input.addEventListener('keydown', function(e) {
            if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
                e.preventDefault();
                sendMessage();
            } else if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });

        sendBtn.addEventListener('click', sendMessage);

        // ========== MODE SWITCHING ==========
        modeFast.addEventListener('click', () => switchMode('fast'));
        modeDeep3.addEventListener('click', () => switchMode('deep3'));
        modeDeep6.addEventListener('click', () => switchMode('deep6'));
        modeSearch.addEventListener('click', () => switchMode('search'));
        modeSearchDeep.addEventListener('click', () => switchMode('searchdeep'));

        function switchMode(mode) {
            currentMode = mode;

            // Update buttons
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`mode-${mode}`).classList.add('active');

            // Update banner and searchdeep select visibility
            const searchdeepSelect = document.getElementById('searchdeep-mode');
            if (mode === 'fast') {
                modeBanner.classList.remove('active');
                searchdeepSelect.classList.remove('visible');
            } else {
                modeBanner.classList.add('active');
                modeBanner.className = `mode-banner active ${mode}`;

                // Show/hide searchdeep mode selector
                if (mode === 'searchdeep') {
                    searchdeepSelect.classList.add('visible');
                    const selectedDeep = searchdeepSelect.value;
                    modeBannerIcon.textContent = 'üîç';
                    modeBannerText.textContent = `Search+Deep Mode ‚Äî Web search + ${selectedDeep === 'deep6' ? 'Deep6 (6-step)' : 'Deep3 (3-step)'} analysis`;
                } else {
                    searchdeepSelect.classList.remove('visible');
                }

                if (mode === 'deep3') {
                    modeBannerIcon.textContent = 'üß†';
                    modeBannerText.textContent = 'Deep3 Mode ‚Äî 3-step reasoning (fast deep thinking)';
                } else if (mode === 'deep6') {
                    modeBannerIcon.textContent = 'üß†';
                    modeBannerText.textContent = 'Deep6 Mode ‚Äî 6-step Minsky Chain-of-Thought';
                } else if (mode === 'search') {
                    modeBannerIcon.textContent = 'üåê';
                    modeBannerText.textContent = 'Search Mode ‚Äî Fast web search (direct results)';
                }
            }

            // Always sync mode with backend
            const modeMap = { 'fast': 'fast', 'deep3': 'deep3', 'deep6': 'deep6', 'search': 'search', 'searchdeep': 'searchdeep' };
            fetch('/api/mode', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode: modeMap[mode] || 'fast' })
            }).catch(() => {});
        }

        // ========== SEARCHDEEP MODE SELECT ==========
        document.getElementById('searchdeep-mode').addEventListener('change', function() {
            const deepMode = this.value;
            // Sync with backend
            fetch('/api/searchdeep/mode', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ mode: deepMode })
            }).then(res => res.json()).then(data => {
                if (data.success) {
                    // Update banner text
                    const modeBannerText = document.getElementById('mode-banner-text');
                    modeBannerText.textContent = `Search+Deep Mode ‚Äî Web search + ${deepMode === 'deep6' ? 'Deep6 (6-step)' : 'Deep3 (3-step)'} analysis`;
                }
            }).catch(() => {});
        });

        // ========== UPDATE LOADING ==========
        function updateLoading(id, text) {
            const el = document.getElementById(id);
            if (el) {
                const textEl = el.querySelector('.loading-text');
                if (textEl) textEl.textContent = text;
            }
        }

        // ========== SEND MESSAGE (SSE STREAMING) ==========
        async function sendMessage() {
            const message = input.value.trim();
            if (!message || isProcessing) return;

            isProcessing = true;
            sendBtn.disabled = true;
            stopBtn.classList.add('visible');
            input.value = '';
            input.style.height = '63px';  // Reset to 3 lines

            // Create AbortController for this request
            abortController = new AbortController();

            // Add mode prefix if needed
            let finalMessage = message;
            if (currentMode === 'deep3' && !message.toUpperCase().startsWith('[DEEP3]')) {
                finalMessage = `[DEEP3] ${message}`;
            } else if (currentMode === 'deep6' && !message.toUpperCase().startsWith('[DEEP6]')) {
                finalMessage = `[DEEP6] ${message}`;
            } else if (currentMode === 'search' && !message.startsWith('/search ')) {
                finalMessage = `/search ${message}`;
            } else if (currentMode === 'searchdeep' && !message.toUpperCase().startsWith('[SEARCH+DEEP]')) {
                finalMessage = `[SEARCH+DEEP] ${message}`;
            }

            addMessage('user', message);
            const loadingId = showLoading('Processing...');

            let stepCount = 0;
            let totalSteps = 0;
            let hasToolCalls = false;
            let lastRouteMethod = '';

            try {
                const response = await fetch('/api/chat/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: finalMessage }),
                    signal: abortController.signal
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });

                    // Process complete SSE lines
                    const lines = buffer.split('\n');
                    buffer = lines.pop(); // Keep incomplete line in buffer

                    for (const line of lines) {
                        if (!line.startsWith('data: ')) continue;

                        let event;
                        try {
                            event = JSON.parse(line.slice(6));
                        } catch (e) {
                            continue;
                        }

                        switch (event.event) {
                            case 'status':
                                updateLoading(loadingId, event.text);
                                break;

                            case 'tool_start':
                                stepCount++;
                                totalSteps++;
                                const label = TOOL_LABELS[event.tool] || event.tool;
                                const fileHint = event.params?.file_path
                                    ? ` ${event.params.file_path}` : '';
                                updateLoading(loadingId,
                                    `[${stepCount}] ${label}${fileHint}...`);
                                break;

                            case 'tool_result':
                                hasToolCalls = true;
                                addToolCall({
                                    tool: event.tool,
                                    params: event.params,
                                    result: event.result
                                });
                                break;

                            case 'thinking':
                                if (event.steps && event.steps.length > 0) {
                                    addThinking(event.steps);
                                }
                                break;

                            case 'response':
                                lastRouteMethod = event.route_method || '';
                                hideLoading(loadingId);
                                if (event.text) {
                                    // Show response for: no tools, llm, deep_search, pattern+llm_analysis
                                    const showResponse = !hasToolCalls ||
                                        lastRouteMethod === 'llm' ||
                                        lastRouteMethod === 'deep_search' ||
                                        lastRouteMethod === 'pattern+llm_analysis';
                                    if (showResponse) {
                                        addMessage('assistant', event.text, lastRouteMethod);
                                    }
                                }
                                break;

                            case 'error':
                                hideLoading(loadingId);
                                addMessage('system', `Error: ${event.text || 'Unknown error'}`);
                                break;

                            case 'choice_request':
                                hideLoading(loadingId);
                                renderChoicePrompt(event);
                                break;

                            case 'approval_required':
                                hideLoading(loadingId);
                                renderApprovalPrompt(event);
                                break;

                            case 'approval_resolved':
                                // Approval was resolved (by another client or timeout)
                                hideApprovalPrompt(event.request_id);
                                break;

                            case 'done':
                                hideLoading(loadingId);
                                // Show SWECAS classification if present
                                if (event.swecas && event.swecas.category) {
                                    const swecasTag = document.createElement('div');
                                    swecasTag.className = 'swecas-tag';
                                    swecasTag.innerHTML = `<span class="swecas-badge">SWECAS-${event.swecas.category}</span> ${event.swecas.name}`;
                                    const lastMsg = messagesContainer.querySelector('.message-row:last-child .message-content');
                                    if (lastMsg) {
                                        lastMsg.appendChild(swecasTag);
                                    }
                                }
                                break;
                        }
                    }
                }

                // Ensure loading is hidden
                hideLoading(loadingId);

            } catch (error) {
                hideLoading(loadingId);
                if (error.name === 'AbortError') {
                    addMessage('system', 'Request stopped by user');
                } else {
                    // Fallback to non-streaming API
                    console.warn('SSE failed, falling back to /api/chat:', error.message);
                    await sendMessageFallback(finalMessage, message, loadingId);
                }
            }

            isProcessing = false;
            sendBtn.disabled = false;
            stopBtn.classList.remove('visible');
            abortController = null;
            input.focus();
        }

        // ========== FALLBACK (non-streaming) ==========
        async function sendMessageFallback(finalMessage, originalMessage, loadingId) {
            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: finalMessage })
                });

                const data = await response.json();
                hideLoading(loadingId);

                if (data.success) {
                    if (data.thinking && data.thinking.length > 0) {
                        addThinking(data.thinking);
                    }

                    const hasToolCalls = data.tool_calls && data.tool_calls.length > 0;
                    if (hasToolCalls) {
                        for (const tc of data.tool_calls) {
                            addToolCall(tc);
                        }
                    }

                    if (!hasToolCalls && data.response) {
                        addMessage('assistant', data.response, data.route_method);
                    } else if (hasToolCalls && data.route_method === 'llm' && data.response) {
                        addMessage('assistant', data.response, data.route_method);
                    }
                } else {
                    addMessage('system', `Error: ${data.error || 'Unknown error'}`);
                }
            } catch (e) {
                hideLoading(loadingId);
                addMessage('system', `Error: ${e.message}`);
            }
        }

        // ========== STOP REQUEST ==========
        function stopRequest() {
            if (abortController) {
                abortController.abort();
            }
        }

        stopBtn.addEventListener('click', stopRequest);

        // ========== ADD MESSAGE ==========
        function addMessage(type, content, routeMethod = null) {
            const div = document.createElement('div');
            div.className = 'message';

            if (type === 'user') {
                // Handle multiline user input
                const userContent = escapeHtml(content).replace(/\n/g, '<br>');
                div.innerHTML = `
                    <div class="message-user">
                        <span class="message-prompt">‚ùØ</span>
                        <span class="message-content">${userContent}</span>
                    </div>
                `;
            } else if (type === 'assistant') {
                // Unified formatting for ALL modes (Fast, Deep, Search, AI+Search)
                const routeIcon = getRouteIcon(routeMethod);
                const routeLabel = getRouteLabel(routeMethod);
                const showHeader = routeMethod && routeMethod !== '';

                div.innerHTML = `
                    <div class="message-assistant">
                        ${showHeader ? `
                            <div class="message-header">
                                <span>${routeIcon}</span>
                                <span>${routeLabel}</span>
                            </div>
                        ` : ''}
                        <div class="message-body">
                            ${formatContent(content)}
                        </div>
                    </div>
                `;
            } else {
                div.innerHTML = `<div class="message-system">${content}</div>`;
            }

            output.appendChild(div);
            scrollToBottom();

            // Highlight code & add copy buttons
            div.querySelectorAll('pre code').forEach(block => {
                hljs.highlightElement(block);
            });

            // Highlight code blocks with line numbers (Claude Code style)
            div.querySelectorAll('.code-block-content').forEach(block => {
                const lang = block.dataset.lang;
                if (lang && lang !== 'plaintext') {
                    block.querySelectorAll('.code-line-content').forEach(lineEl => {
                        const text = lineEl.textContent;
                        try {
                            const result = hljs.highlight(text, { language: lang, ignoreIllegals: true });
                            lineEl.innerHTML = result.value;
                        } catch (e) {
                            // Language not supported, keep original
                        }
                    });
                }
            });

            addCopyButtons(div);
        }

        // ========== ROUTE ICONS AND LABELS ==========
        function getRouteIcon(routeMethod) {
            const icons = {
                'pattern': '‚ö°',
                'llm': 'ü§ñ',
                'deep_search': 'üåê',
                'pattern+llm_analysis': 'üîç',
                'special_command': '‚åò'
            };
            return icons[routeMethod] || 'üí¨';
        }

        function getRouteLabel(routeMethod) {
            const labels = {
                'pattern': 'Quick Response',
                'llm': 'AI Response',
                'deep_search': 'Web Search + Analysis',
                'pattern+llm_analysis': 'Search + AI Analysis',
                'special_command': 'Command'
            };
            return labels[routeMethod] || 'Response';
        }

        // ========== TOGGLE ALL COLLAPSED (Ctrl+O) ==========
        function toggleAllCollapsed() {
            const collapsibles = document.querySelectorAll('.collapsible.collapsed');
            if (collapsibles.length > 0) {
                // Expand all
                collapsibles.forEach(el => el.classList.remove('collapsed'));
                showStatus('Expanded all sections', 'success');
            } else {
                // Collapse all expandable
                const expandables = document.querySelectorAll('.collapsible:not(.collapsed)');
                expandables.forEach(el => el.classList.add('collapsed'));
                showStatus('Collapsed all sections', 'info');
            }
        }

        // Toggle single collapsible
        function toggleCollapsible(element) {
            element.classList.toggle('collapsed');
        }

        // Count lines in content
        function countLines(str) {
            return (str.match(/\n/g) || []).length + 1;
        }

        // Create collapsible wrapper
        function createCollapsible(summary, content, startCollapsed = true) {
            const wrapper = document.createElement('div');
            wrapper.className = 'collapsible' + (startCollapsed ? ' collapsed' : '');

            const summaryEl = document.createElement('div');
            summaryEl.className = 'collapse-summary';
            summaryEl.innerHTML = `
                <span class="expand-btn"><span class="arrow">‚ñº</span></span>
                <span>${summary}</span>
                <span class="expand-hint">(ctrl+o to expand)</span>
            `;
            summaryEl.onclick = () => toggleCollapsible(wrapper);

            const contentEl = document.createElement('div');
            contentEl.className = 'collapsible-content';
            if (typeof content === 'string') {
                contentEl.innerHTML = content;
            } else {
                contentEl.appendChild(content);
            }

            wrapper.appendChild(summaryEl);
            wrapper.appendChild(contentEl);
            return wrapper;
        }

        // ========== ADD TOOL CALL ==========
        function addToolCall(tc) {
            const div = document.createElement('div');
            div.className = 'tool-call';

            const icon = TOOL_ICONS[tc.tool] || TOOL_ICONS.default;
            const truncate = (str, len = 50) => {
                if (typeof str !== 'string') str = String(str);
                return str.length > len ? str.substring(0, len) + '...' : str;
            };

            const params = Object.entries(tc.params || {})
                .map(([k, v]) => `${k}="${truncate(v)}"`)
                .join(', ');

            const isSuccess = tc.result.success !== false;
            const statusClass = isSuccess ? 'success' : 'error';
            const statusIcon = isSuccess ? '‚úì' : '‚úó';

            const resultStr = isSuccess ?
                formatToolResult(tc.tool, tc.result) :
                `<span style="color: var(--accent-red)">Error: ${escapeHtml(tc.result.error)}</span>`;

            // Check if result is large (should be collapsed)
            const resultText = tc.result.content || tc.result.output || JSON.stringify(tc.result);
            const lineCount = countLines(resultText);
            const shouldCollapse = lineCount > 10 || resultText.length > 500;

            const headerHtml = `
                <div class="tool-header">
                    <span class="tool-icon">${icon}</span>
                    <span class="tool-name">${tc.tool}</span>
                    <span class="tool-params">(${params})</span>
                    <span class="tool-status ${statusClass}">${statusIcon}</span>
                </div>
            `;

            if (shouldCollapse) {
                // Create collapsible tool result
                div.innerHTML = headerHtml;
                const summary = `${tc.tool} result: <span class="line-count">${lineCount} lines</span>`;
                const collapsible = createCollapsible(summary, `<div class="tool-result">${resultStr}</div>`, true);
                div.appendChild(collapsible);
            } else {
                div.innerHTML = headerHtml + `<div class="tool-result">${resultStr}</div>`;
            }

            output.appendChild(div);
            scrollToBottom();
        }

        // ========== ADD THINKING ==========
        function addThinking(thinking) {
            const div = document.createElement('div');
            div.className = 'thinking-block collapsible collapsed';

            const content = Array.isArray(thinking) ? thinking.join('\n') : thinking;
            const lineCount = countLines(content);
            const preview = content.substring(0, 100).replace(/\n/g, ' ') + (content.length > 100 ? '...' : '');

            div.innerHTML = `
                <div class="thinking-header collapse-summary" onclick="toggleCollapsible(this.parentElement)">
                    <span class="expand-btn"><span class="arrow">‚ñº</span></span>
                    <span>üß†</span>
                    <span>Thinking</span>
                    <span class="line-count">(${lineCount} lines)</span>
                    <span class="expand-hint">(ctrl+o to expand)</span>
                </div>
                <div class="collapsible-content">
                    <div class="thinking-content">${escapeHtml(content)}</div>
                </div>
            `;

            output.appendChild(div);
            scrollToBottom();
        }

        // ========== LOADING ==========
        function showLoading(text = 'Processing...') {
            const id = 'loading-' + Date.now();
            const div = document.createElement('div');
            div.id = id;
            div.className = 'loading';
            div.innerHTML = `
                <div class="loading-spinner"></div>
                <span class="loading-dot"></span>
                <span class="loading-text status-executing">${escapeHtml(text)}</span>
            `;
            output.appendChild(div);
            scrollToBottom();
            return id;
        }

        function hideLoading(id) {
            const el = document.getElementById(id);
            if (el) el.remove();
        }

        // ========== FORMAT CONTENT (with markdown tables) ==========
        function formatContent(content) {
            if (!content) return '';

            // Convert escaped newlines
            let text = content.replace(/\\n/g, '\n');

            // Extract code blocks first (preserve them)
            const codeBlocks = [];
            let processed = text.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => {
                const idx = codeBlocks.length;
                const langName = lang || 'plaintext';
                const codeBlockId = 'codeblock-' + Date.now() + '-' + Math.random().toString(36).slice(2, 6);

                // Render code block with line numbers (Claude Code style)
                codeBlocks.push(renderCodeBlockWithLineNumbers(code.trim(), langName, codeBlockId));
                return `__CODEBLOCK_${idx}__`;
            });

            // Convert space/tab-separated tables to markdown (for Qwen models)
            processed = convertSpaceTableToMarkdown(processed);

            // Extract and render markdown tables
            const tables = [];
            const tableRegex = /(\|[^\n]+\|\n?)+/g;
            processed = processed.replace(tableRegex, (tableMatch) => {
                const tableHtml = renderMarkdownTable(tableMatch);
                if (tableHtml) {
                    const idx = tables.length;
                    tables.push(tableHtml);
                    return `__TABLE_${idx}__`;
                }
                return tableMatch;
            });

            // Escape HTML
            let html = escapeHtml(processed);

            // Inline code
            html = html.replace(/`([^`]+)`/g, '<code>$1</code>');

            // Bold
            html = html.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');

            // Italic
            html = html.replace(/\*([^*]+)\*/g, '<em>$1</em>');

            // Links [text](url)
            html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2" target="_blank" style="color:var(--accent-blue)">$1</a>');

            // Headers (## Header)
            html = html.replace(/^### (.+)$/gm, '<strong style="color:var(--accent-cyan);font-size:14px">$1</strong>');
            html = html.replace(/^## (.+)$/gm, '<strong style="color:var(--accent-cyan);font-size:15px">$1</strong>');
            html = html.replace(/^# (.+)$/gm, '<strong style="color:var(--accent-cyan);font-size:16px">$1</strong>');

            // Bullet lists (- item)
            html = html.replace(/^- (.+)$/gm, '‚Ä¢ $1');

            // Line breaks
            html = html.replace(/\n/g, '<br>');

            // Restore tables
            tables.forEach((table, i) => {
                html = html.replace(`__TABLE_${i}__`, table);
            });

            // Restore code blocks
            codeBlocks.forEach((block, i) => {
                html = html.replace(`__CODEBLOCK_${i}__`, block);
            });

            return html;
        }

        // ========== CODE BLOCK WITH LINE NUMBERS (Claude Code style) ==========
        function renderCodeBlockWithLineNumbers(code, lang, blockId) {
            const lines = code.split('\n');
            const lineCount = lines.length;

            // Calculate line number width based on max line number
            const lineNumWidth = Math.max(40, String(lineCount).length * 10 + 20);

            let linesHtml = '';
            lines.forEach((line, i) => {
                const lineNum = i + 1;
                const escapedLine = line
                    .replace(/&/g, '&amp;')
                    .replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;');

                linesHtml += `<div class="code-line">
                    <span class="code-line-number">${lineNum}</span>
                    <span class="code-line-content">${escapedLine || ' '}</span>
                </div>`;
            });

            return `
                <div class="code-block-wrapper" id="${blockId}">
                    <div class="code-block-header">
                        <span class="code-block-lang">${lang}</span>
                        <button class="code-copy-btn" onclick="copyCodeBlock('${blockId}')">Copy</button>
                    </div>
                    <div class="code-block-content" data-lang="${lang}">
                        ${linesHtml}
                    </div>
                </div>
            `;
        }

        // Copy code from block with line numbers
        function copyCodeBlock(blockId) {
            const block = document.getElementById(blockId);
            if (!block) return;

            const lines = block.querySelectorAll('.code-line-content');
            const text = Array.from(lines).map(l => l.textContent).join('\n');

            navigator.clipboard.writeText(text).then(() => {
                const btn = block.querySelector('.code-copy-btn');
                if (btn) {
                    btn.textContent = 'Copied!';
                    btn.classList.add('copied');
                    setTimeout(() => {
                        btn.textContent = 'Copy';
                        btn.classList.remove('copied');
                    }, 2000);
                }
            });
        }

        // ========== SPACE/TAB TABLE TO MARKDOWN CONVERTER ==========
        // Converts Qwen-style tables (4+ spaces between columns) to proper markdown
        function convertSpaceTableToMarkdown(text) {
            const lines = text.split('\n');
            const result = [];
            let tableLines = [];
            let inTable = false;

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                // Detect table rows: has columns separated by 4+ spaces or tabs
                // This is the Qwen output style: "Feature    **Docker**    **Podman**"
                const hasMultipleCols = (line.match(/\s{4,}|\t/g) || []).length >= 2;
                const isTableRow = hasMultipleCols && line.trim().length > 15;

                if (isTableRow) {
                    inTable = true;
                    tableLines.push(line);
                } else {
                    if (inTable && tableLines.length >= 2) {
                        // Convert accumulated table lines to markdown
                        const mdTable = convertTableLinesToMarkdown(tableLines);
                        result.push(mdTable);
                    } else if (tableLines.length > 0) {
                        // Not enough lines for a table, push as-is
                        result.push(...tableLines);
                    }
                    tableLines = [];
                    inTable = false;
                    result.push(line);
                }
            }

            // Handle remaining table at end
            if (inTable && tableLines.length >= 2) {
                result.push(convertTableLinesToMarkdown(tableLines));
            } else {
                result.push(...tableLines);
            }

            return result.join('\n');
        }

        function convertTableLinesToMarkdown(lines) {
            if (lines.length < 2) return lines.join('\n');

            // Split each line by 4+ spaces or tabs (Qwen separator)
            const rows = lines.map(line => {
                return line.trim().split(/\s{4,}|\t+/).map(cell => cell.trim()).filter(cell => cell);
            });

            // Find max columns
            const maxCols = Math.max(...rows.map(r => r.length));
            if (maxCols < 2) return lines.join('\n');

            // Build markdown table
            const mdLines = [];
            rows.forEach((row, idx) => {
                // Pad row to max columns
                while (row.length < maxCols) row.push('');
                const mdRow = '| ' + row.join(' | ') + ' |';
                mdLines.push(mdRow);

                // Add separator after header (first row)
                if (idx === 0) {
                    const separator = '| ' + row.map(() => '---').join(' | ') + ' |';
                    mdLines.push(separator);
                }
            });

            return mdLines.join('\n');
        }

        // ========== MARKDOWN TABLE RENDERER ==========
        function renderMarkdownTable(tableText) {
            const lines = tableText.trim().split('\n').filter(l => l.trim());
            if (lines.length < 2) return null;

            // Check if it's a valid markdown table
            const headerLine = lines[0];
            const separatorLine = lines[1];

            // Separator line should contain dashes and pipes (e.g., |---|---|)
            // More lenient regex: just needs | and --- somewhere
            const isSeparator = separatorLine.includes('|') && separatorLine.includes('---');
            if (!isSeparator) {
                return null;
            }

            // Parse header
            const headers = headerLine.split('|').map(h => h.trim()).filter(h => h);

            // Parse body rows
            const bodyRows = [];
            for (let i = 2; i < lines.length; i++) {
                const cells = lines[i].split('|').map(c => c.trim()).filter(c => c !== '');
                if (cells.length > 0) {
                    bodyRows.push(cells);
                }
            }

            // Build HTML table
            let html = '<table class="md-table"><thead><tr>';
            headers.forEach(h => {
                html += `<th>${escapeHtml(h)}</th>`;
            });
            html += '</tr></thead><tbody>';

            bodyRows.forEach(row => {
                html += '<tr>';
                row.forEach(cell => {
                    html += `<td>${escapeHtml(cell)}</td>`;
                });
                // Fill empty cells if row is shorter than header
                for (let i = row.length; i < headers.length; i++) {
                    html += '<td></td>';
                }
                html += '</tr>';
            });

            html += '</tbody></table>';
            return html;
        }

        // ========== FORMAT TOOL RESULT ==========
        function formatToolResult(tool, result) {
            if (tool === 'ls') {
                const items = result.items || [];
                return items.slice(0, 30).map(item => {
                    const icon = item.type === 'dir' ? 'üìÅ' : 'üìÑ';
                    return `${icon} ${escapeHtml(item.name)}`;
                }).join('<br>') + (items.length > 30 ? `<br><span style="color:var(--text-muted)">... +${items.length - 30} more</span>` : '');
            }

            if (tool === 'read') {
                const content = result.content || '';
                // Backend returns "     N: content" format ‚Äî strip the line-number prefix
                const rawLines = content.split('\n').slice(0, 100);
                const lines = rawLines.map(l => l.replace(/^\s*\d+:\s?/, ''));
                const startLine = (result.offset || 0) + 1;
                return formatDiffView(result.file_path || 'file', lines, null, 'read', startLine);
            }

            if (tool === 'grep') {
                const matches = result.matches || [];
                return matches.slice(0, 20).map(m =>
                    `<span style="color:var(--text-muted)">${escapeHtml(m.file)}:${m.line_number}:</span> ${escapeHtml(m.line)}`
                ).join('<br>');
            }

            if (tool === 'bash') {
                const stdout = result.stdout || '';
                const stderr = result.stderr || '';
                let html = stdout ? `<pre style="margin:0">${escapeHtml(stdout)}</pre>` : '';
                if (stderr) {
                    html += `<pre style="margin:0;color:var(--accent-red)">${escapeHtml(stderr)}</pre>`;
                }
                return html || '<span style="color:var(--text-muted)">(no output)</span>';
            }

            if (tool === 'edit' || tool === 'write' || tool === 'code_inject') {
                const file = result.file_path || result.file || 'file';
                const oldContent = result.old_content || '';
                const newContent = result.new_content || '';
                const startLine = result.context_start_line || 1;

                if (oldContent || newContent) {
                    return formatDiffView(file,
                        newContent ? newContent.split('\n') : [],
                        oldContent ? oldContent.split('\n') : [],
                        tool, startLine
                    );
                }
                const action = tool === 'write' ? 'written' : 'edited';
                return `<span style="color:var(--accent-green)">‚úì File ${action}: ${escapeHtml(file)}</span>`;
            }

            return `<pre style="margin:0">${escapeHtml(JSON.stringify(result, null, 2))}</pre>`;
        }

        // ========== LCS DIFF ALGORITHM ==========
        function computeLCS(a, b) {
            const m = a.length, n = b.length;
            // For very large files, skip LCS and fall back to naive
            if (m * n > 500000) return null;

            const dp = Array.from({length: m + 1}, () => new Uint16Array(n + 1));
            for (let i = 1; i <= m; i++) {
                for (let j = 1; j <= n; j++) {
                    dp[i][j] = a[i-1] === b[j-1]
                        ? dp[i-1][j-1] + 1
                        : Math.max(dp[i-1][j], dp[i][j-1]);
                }
            }

            // Backtrack to produce diff ops
            const ops = [];
            let i = m, j = n;
            while (i > 0 || j > 0) {
                if (i > 0 && j > 0 && a[i-1] === b[j-1]) {
                    ops.push({type: 'context', oldIdx: i-1, newIdx: j-1, text: a[i-1]});
                    i--; j--;
                } else if (j > 0 && (i === 0 || dp[i][j-1] >= dp[i-1][j])) {
                    ops.push({type: 'added', newIdx: j-1, text: b[j-1]});
                    j--;
                } else {
                    ops.push({type: 'removed', oldIdx: i-1, text: a[i-1]});
                    i--;
                }
            }
            return ops.reverse();
        }

        // ========== FILE EXT ‚Üí HLJS LANGUAGE ==========
        const EXT_TO_LANG = {
            'py': 'python', 'js': 'javascript', 'ts': 'typescript', 'jsx': 'javascript',
            'tsx': 'typescript', 'go': 'go', 'rs': 'rust', 'rb': 'ruby', 'java': 'java',
            'c': 'c', 'cpp': 'cpp', 'h': 'c', 'hpp': 'cpp', 'cs': 'csharp',
            'sh': 'bash', 'bash': 'bash', 'zsh': 'bash', 'bat': 'dos', 'ps1': 'powershell',
            'sql': 'sql', 'html': 'xml', 'htm': 'xml', 'xml': 'xml', 'svg': 'xml',
            'css': 'css', 'scss': 'scss', 'less': 'less',
            'json': 'json', 'yaml': 'yaml', 'yml': 'yaml', 'toml': 'ini',
            'md': 'markdown', 'dockerfile': 'dockerfile', 'makefile': 'makefile',
            'tf': 'hcl', 'hcl': 'hcl', 'lua': 'lua', 'php': 'php', 'swift': 'swift',
            'kt': 'kotlin', 'r': 'r', 'pl': 'perl'
        };

        function getLangFromFile(filePath) {
            if (!filePath) return null;
            const name = filePath.split(/[/\\]/).pop().toLowerCase();
            if (name === 'dockerfile' || name.startsWith('dockerfile.')) return 'dockerfile';
            if (name === 'makefile' || name === 'gnumakefile') return 'makefile';
            const ext = name.includes('.') ? name.split('.').pop() : '';
            return EXT_TO_LANG[ext] || null;
        }

        // ========== DIFF VIEW (Claude Code style - single line number) ==========
        function formatDiffView(file, newLines, oldLines, action, startLine) {
            startLine = startLine || 1;
            const lang = getLangFromFile(file);
            const diffId = 'diff-' + Date.now() + '-' + Math.random().toString(36).slice(2, 6);
            let addedCount = 0, removedCount = 0;

            let html = `<div class="diff-container" id="${diffId}">
                <div class="diff-header">
                    <span class="diff-header-icon">‚óè</span>
                    <span class="diff-header-text">${action === 'read' ? 'Read' : 'Edit'}</span>
                    <span class="diff-header-file">${escapeHtml(file)}</span>
                    <div class="diff-stats">__DIFF_STATS__</div>
                </div>
                <div class="diff-content">`;

            if (action === 'read') {
                // Read mode: single line-number column, no sign column
                newLines.forEach((line, i) => {
                    html += `<div class="diff-line diff-context">
                        <span class="diff-line-number">${startLine + i}</span>
                        <span class="diff-line-content">${escapeHtml(line)}</span>
                    </div>`;
                });
            } else {
                // Diff mode: LCS-based with single line number (Claude Code style)
                const ops = (oldLines && oldLines.length > 0)
                    ? computeLCS(oldLines, newLines)
                    : null;

                if (ops) {
                    // Claude Code style: single line number showing current position
                    let lineNum = startLine;
                    ops.forEach(op => {
                        if (op.type === 'context') {
                            html += `<div class="diff-line diff-context">
                                <span class="diff-line-number">${lineNum}</span>
                                <span class="diff-line-sign"> </span>
                                <span class="diff-line-content">${escapeHtml(op.text)}</span>
                            </div>`;
                            lineNum++;
                        } else if (op.type === 'removed') {
                            removedCount++;
                            html += `<div class="diff-line diff-removed">
                                <span class="diff-line-number">${lineNum}</span>
                                <span class="diff-line-sign">-</span>
                                <span class="diff-line-content">${escapeHtml(op.text)}</span>
                            </div>`;
                            lineNum++;
                        } else if (op.type === 'added') {
                            addedCount++;
                            html += `<div class="diff-line diff-added">
                                <span class="diff-line-number">${lineNum}</span>
                                <span class="diff-line-sign">+</span>
                                <span class="diff-line-content">${escapeHtml(op.text)}</span>
                            </div>`;
                            lineNum++;
                        }
                    });
                } else {
                    // Fallback for very large diffs or new files (no old content)
                    newLines.forEach((line, i) => {
                        addedCount++;
                        html += `<div class="diff-line diff-added">
                            <span class="diff-line-number">${startLine + i}</span>
                            <span class="diff-line-sign">+</span>
                            <span class="diff-line-content">${escapeHtml(line)}</span>
                        </div>`;
                    });
                }
            }

            html += '</div></div>';

            // Insert stats
            if (action !== 'read') {
                const statsHtml =
                    (addedCount ? `<span class="diff-stats-added">+${addedCount}</span> ` : '') +
                    (removedCount ? `<span class="diff-stats-removed">-${removedCount}</span>` : '');
                html = html.replace('__DIFF_STATS__', statsHtml);
            } else {
                html = html.replace('__DIFF_STATS__', '');
            }

            // Schedule syntax highlighting after DOM insertion
            if (lang) {
                setTimeout(() => {
                    const container = document.getElementById(diffId);
                    if (!container) return;
                    container.querySelectorAll('.diff-line-content').forEach(el => {
                        const code = document.createElement('code');
                        code.className = `language-${lang}`;
                        code.textContent = el.textContent;
                        el.textContent = '';
                        el.appendChild(code);
                        hljs.highlightElement(code);
                    });
                }, 0);
            }

            return html;
        }

        // ========== COPY CODE ==========
        function copyCode(btn) {
            const pre = btn.closest('.code-block-wrapper').querySelector('pre code');
            const text = pre.textContent;

            navigator.clipboard.writeText(text).then(() => {
                btn.textContent = 'Copied!';
                btn.classList.add('copied');
                setTimeout(() => {
                    btn.textContent = 'Copy';
                    btn.classList.remove('copied');
                }, 2000);
            });
        }

        function addCopyButtons(container) {
            // Already handled in formatContent
        }

        // ========== UTILITY ==========
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function scrollToBottom() {
            output.scrollTop = output.scrollHeight;
        }

        // ========== HEALTH CHECK ==========
        async function checkHealth() {
            try {
                const r = await fetch('/api/health');
                const data = await r.json();

                if (data.ollama) {
                    statusDot.classList.remove('offline');
                    statusText.textContent = 'Connected';
                    modelBadge.textContent = data.model;
                } else {
                    statusDot.classList.add('offline');
                    statusText.textContent = 'Ollama offline';
                }
            } catch (e) {
                statusDot.classList.add('offline');
                statusText.textContent = 'Disconnected';
            }
        }

        checkHealth();
        setInterval(checkHealth, 30000);

        // ========== CONFIRMATION SYSTEM ==========
        function renderChoices(choices, messageId, question) {
            pendingConfirmation = { choices, messageId };
            selectedChoiceIndex = choices.findIndex(c => c.default) || 0;

            const div = document.createElement('div');
            div.id = `choices-${messageId}`;
            div.className = 'choices-container';

            div.innerHTML = `
                <div class="choices-question">${escapeHtml(question || 'Do you want to proceed?')}</div>
                <div class="choices-list">
                    ${choices.map((choice, i) => `
                        <div class="choice-item ${i === selectedChoiceIndex ? 'choice-active' : ''}"
                             data-index="${i}" data-id="${choice.id}">
                            <span class="choice-marker">${i === selectedChoiceIndex ? '>' : ' '}</span>
                            <span class="choice-number">${choice.id}.</span>
                            <span>${escapeHtml(choice.text)}</span>
                            <span class="choice-shortcut">${choice.shortcut}</span>
                        </div>
                    `).join('')}
                </div>
                <div class="choices-hint">‚Üë‚Üì navigate ‚Ä¢ Enter select ‚Ä¢ Esc cancel ‚Ä¢ 1-3 quick select</div>
            `;

            setTimeout(() => {
                div.querySelectorAll('.choice-item').forEach(item => {
                    item.addEventListener('click', () => confirmChoice(parseInt(item.dataset.index)));
                });
            }, 0);

            output.appendChild(div);
            scrollToBottom();
        }

        // ========== CLAUDE CODE STYLE CHOICE PROMPT (Yes / Yes, and... / No) ==========
        let activeChoicePrompt = null;

        function renderChoicePrompt(event) {
            const promptId = 'choice-' + Date.now();
            const context = event.context || event.question || 'Apply changes?';

            const div = document.createElement('div');
            div.id = promptId;
            div.className = 'choice-container';

            div.innerHTML = `
                <div class="choice-context">${escapeHtml(context)}</div>
                <div class="choice-options">
                    <div class="choice-option" data-key="y" data-action="approve">
                        <span class="choice-key">y</span>
                        <span>Yes</span>
                    </div>
                    <div class="choice-option" data-key="a" data-action="approve_with_input">
                        <span class="choice-key">a</span>
                        <span>Yes, and...</span>
                    </div>
                    <div class="choice-option" data-key="n" data-action="reject">
                        <span class="choice-key">n</span>
                        <span>No</span>
                    </div>
                </div>
                <div class="choice-input-area" style="display:none">
                    <textarea placeholder="Add your instructions..."></textarea>
                    <div class="choice-buttons">
                        <button class="choice-submit">Submit</button>
                        <button class="choice-cancel">Cancel</button>
                    </div>
                </div>
                <div class="choice-hint">Press y (yes), a (yes, and...), or n (no)</div>
            `;

            output.appendChild(div);
            scrollToBottom();

            // Store active prompt
            activeChoicePrompt = {
                id: promptId,
                event: event,
                selectedKey: null,
                instruction: ''
            };

            // Click handlers
            div.querySelectorAll('.choice-option').forEach(opt => {
                opt.addEventListener('click', () => handleChoiceClick(opt.dataset.key, opt.dataset.action));
            });

            // Submit/Cancel for "Yes, and..."
            const submitBtn = div.querySelector('.choice-submit');
            const cancelBtn = div.querySelector('.choice-cancel');
            const textarea = div.querySelector('textarea');

            submitBtn.addEventListener('click', () => {
                const instruction = textarea.value.trim();
                submitChoicePrompt('yes', instruction);
            });

            cancelBtn.addEventListener('click', () => {
                const inputArea = div.querySelector('.choice-input-area');
                inputArea.style.display = 'none';
                div.querySelectorAll('.choice-option').forEach(o => o.classList.remove('choice-selected'));
                activeChoicePrompt.selectedKey = null;
            });
        }

        function handleChoiceClick(key, action) {
            if (!activeChoicePrompt) return;
            const container = document.getElementById(activeChoicePrompt.id);
            if (!container) return;

            // Update selection UI
            container.querySelectorAll('.choice-option').forEach(o => o.classList.remove('choice-selected'));
            const selected = container.querySelector(`[data-key="${key}"]`);
            if (selected) selected.classList.add('choice-selected');

            if (action === 'approve_with_input') {
                // Show input area for "Yes, and..."
                const inputArea = container.querySelector('.choice-input-area');
                inputArea.style.display = 'block';
                const textarea = inputArea.querySelector('textarea');
                textarea.focus();
                activeChoicePrompt.selectedKey = key;
            } else if (action === 'approve') {
                submitChoicePrompt('yes', '');
            } else if (action === 'reject') {
                submitChoicePrompt('no', '');
            }
        }

        async function submitChoicePrompt(choice, instruction) {
            if (!activeChoicePrompt) return;
            const container = document.getElementById(activeChoicePrompt.id);

            // Update UI
            if (container) {
                const resultText = choice === 'yes'
                    ? (instruction ? `‚úì Yes, and: "${instruction}"` : '‚úì Yes')
                    : '‚úó No';
                container.innerHTML = `<div style="color: ${choice === 'yes' ? 'var(--accent-green)' : 'var(--accent-red)'}">${resultText}</div>`;
            }

            // Send to server
            try {
                await fetch('/api/choice', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        choice: choice,
                        instruction: instruction,
                        event_id: activeChoicePrompt.event.event_id || null
                    })
                });
            } catch (e) {
                console.error('Choice submit error:', e);
            }

            activeChoicePrompt = null;
        }

        // ========== APPROVAL PROMPT (Human-in-the-Loop) ==========
        let activeApprovalPrompt = null;
        const pendingApprovals = new Map();

        function renderApprovalPrompt(event) {
            const requestId = event.id || ('approval-' + Date.now());
            const tool = event.tool || 'unknown';
            const description = event.description || 'Execute operation?';
            const riskLevel = event.risk_level || 'moderate';
            const params = event.params || {};

            const div = document.createElement('div');
            div.id = `approval-${requestId}`;
            div.className = 'approval-container';
            div.dataset.requestId = requestId;

            // Risk level styling
            const riskColors = {
                'safe': 'var(--accent-green)',
                'low': 'var(--accent-blue)',
                'moderate': 'var(--accent-yellow)',
                'high': 'var(--accent-orange)',
                'dangerous': 'var(--accent-red)',
                'critical': 'var(--accent-red)'
            };
            const riskColor = riskColors[riskLevel] || riskColors.moderate;

            div.innerHTML = `
                <div class="approval-header">
                    <span class="approval-icon">‚ö†Ô∏è</span>
                    <span class="approval-title">Approval Required</span>
                    <span class="approval-risk" style="color: ${riskColor}; border-color: ${riskColor}">
                        ${riskLevel.toUpperCase()}
                    </span>
                </div>
                <div class="approval-description">${escapeHtml(description)}</div>
                <div class="approval-tool">Tool: <code>${escapeHtml(tool)}</code></div>
                ${Object.keys(params).length > 0 ? `
                    <div class="approval-params">
                        <details>
                            <summary>Parameters</summary>
                            <pre>${escapeHtml(JSON.stringify(params, null, 2))}</pre>
                        </details>
                    </div>
                ` : ''}
                <div class="approval-options">
                    <div class="approval-option approval-yes" data-action="yes">
                        <span class="approval-key">y</span>
                        <span>Yes, execute</span>
                    </div>
                    <div class="approval-option approval-yes-and" data-action="yes_and">
                        <span class="approval-key">a</span>
                        <span>Yes, and...</span>
                    </div>
                    <div class="approval-option approval-no" data-action="no">
                        <span class="approval-key">n</span>
                        <span>No, skip</span>
                    </div>
                    ${riskLevel === 'dangerous' || riskLevel === 'critical' ? `
                        <div class="approval-option approval-abort" data-action="abort">
                            <span class="approval-key">x</span>
                            <span>Abort all</span>
                        </div>
                    ` : ''}
                </div>
                <div class="approval-input-area" style="display:none">
                    <textarea placeholder="Add modifications or instructions..."></textarea>
                    <div class="approval-buttons">
                        <button class="approval-submit">Submit</button>
                        <button class="approval-cancel">Cancel</button>
                    </div>
                </div>
                <div class="approval-hint">Press y/a/n${riskLevel === 'dangerous' || riskLevel === 'critical' ? '/x' : ''} or click to respond</div>
            `;

            output.appendChild(div);
            scrollToBottom();

            // Store as active
            activeApprovalPrompt = {
                id: requestId,
                element: div,
                event: event
            };
            pendingApprovals.set(requestId, activeApprovalPrompt);

            // Click handlers
            div.querySelectorAll('.approval-option').forEach(opt => {
                opt.addEventListener('click', () => handleApprovalClick(requestId, opt.dataset.action));
            });

            // Submit/Cancel for modifications
            const submitBtn = div.querySelector('.approval-submit');
            const cancelBtn = div.querySelector('.approval-cancel');
            const textarea = div.querySelector('textarea');

            if (submitBtn) {
                submitBtn.addEventListener('click', () => {
                    const modification = textarea.value.trim();
                    submitApproval(requestId, 'yes_and', modification);
                });
            }

            if (cancelBtn) {
                cancelBtn.addEventListener('click', () => {
                    const inputArea = div.querySelector('.approval-input-area');
                    inputArea.style.display = 'none';
                    div.querySelectorAll('.approval-option').forEach(o => o.classList.remove('approval-selected'));
                });
            }
        }

        function handleApprovalClick(requestId, action) {
            const approval = pendingApprovals.get(requestId);
            if (!approval) return;

            const container = approval.element;

            // Update selection UI
            container.querySelectorAll('.approval-option').forEach(o => o.classList.remove('approval-selected'));
            const selected = container.querySelector(`[data-action="${action}"]`);
            if (selected) selected.classList.add('approval-selected');

            if (action === 'yes_and') {
                // Show input area
                const inputArea = container.querySelector('.approval-input-area');
                inputArea.style.display = 'block';
                const textarea = inputArea.querySelector('textarea');
                textarea.focus();
            } else {
                submitApproval(requestId, action);
            }
        }

        async function submitApproval(requestId, choice, userInput = '') {
            const approval = pendingApprovals.get(requestId);
            if (!approval) return;

            const container = approval.element;

            // Update UI
            const resultIcons = {
                'yes': '‚úì',
                'yes_and': '‚úì',
                'no': '‚úó',
                'skip': '‚è≠',
                'abort': '‚õî'
            };
            const resultColors = {
                'yes': 'var(--accent-green)',
                'yes_and': 'var(--accent-green)',
                'no': 'var(--accent-red)',
                'skip': 'var(--accent-yellow)',
                'abort': 'var(--accent-red)'
            };
            const resultText = userInput
                ? `${resultIcons[choice]} ${choice}: "${userInput}"`
                : `${resultIcons[choice]} ${choice}`;

            container.innerHTML = `<div class="approval-result" style="color: ${resultColors[choice]}">${resultText}</div>`;

            // Send to server
            try {
                await fetch('/api/approval/respond', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        request_id: requestId,
                        choice: choice,
                        user_input: userInput
                    })
                });
            } catch (e) {
                console.error('Approval submit error:', e);
            }

            // Cleanup
            pendingApprovals.delete(requestId);
            if (activeApprovalPrompt && activeApprovalPrompt.id === requestId) {
                activeApprovalPrompt = null;
            }
        }

        function hideApprovalPrompt(requestId) {
            const container = document.getElementById(`approval-${requestId}`);
            if (container) {
                container.innerHTML = '<div class="approval-result" style="color: var(--text-muted)">Resolved externally</div>';
            }
            pendingApprovals.delete(requestId);
            if (activeApprovalPrompt && activeApprovalPrompt.id === requestId) {
                activeApprovalPrompt = null;
            }
        }

        // Keyboard handler for choice prompt
        document.addEventListener('keydown', (e) => {
            // Handle approval prompts first (they take priority)
            if (activeApprovalPrompt) {
                const container = activeApprovalPrompt.element;
                if (!container) return;

                // Don't handle if typing in textarea
                if (document.activeElement.tagName === 'TEXTAREA') {
                    if (e.key === 'Escape') {
                        const inputArea = container.querySelector('.approval-input-area');
                        if (inputArea) {
                            inputArea.style.display = 'none';
                            container.querySelectorAll('.approval-option').forEach(o => o.classList.remove('approval-selected'));
                        }
                    }
                    return;
                }

                const requestId = activeApprovalPrompt.id;

                if (e.key === 'y' || e.key === 'Y') {
                    e.preventDefault();
                    handleApprovalClick(requestId, 'yes');
                } else if (e.key === 'a' || e.key === 'A') {
                    e.preventDefault();
                    handleApprovalClick(requestId, 'yes_and');
                } else if (e.key === 'n' || e.key === 'N') {
                    e.preventDefault();
                    handleApprovalClick(requestId, 'no');
                } else if (e.key === 's' || e.key === 'S') {
                    e.preventDefault();
                    handleApprovalClick(requestId, 'skip');
                } else if (e.key === 'x' || e.key === 'X') {
                    e.preventDefault();
                    handleApprovalClick(requestId, 'abort');
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    submitApproval(requestId, 'no');
                }
                return;
            }

            // Handle choice prompts
            if (!activeChoicePrompt) return;
            const container = document.getElementById(activeChoicePrompt.id);
            if (!container) return;

            // Don't handle if typing in textarea
            if (document.activeElement.tagName === 'TEXTAREA') {
                if (e.key === 'Escape') {
                    const inputArea = container.querySelector('.choice-input-area');
                    inputArea.style.display = 'none';
                    container.querySelectorAll('.choice-option').forEach(o => o.classList.remove('choice-selected'));
                    activeChoicePrompt.selectedKey = null;
                }
                return;
            }

            if (e.key === 'y' || e.key === 'Y') {
                e.preventDefault();
                handleChoiceClick('y', 'approve');
            } else if (e.key === 'a' || e.key === 'A') {
                e.preventDefault();
                handleChoiceClick('a', 'approve_with_input');
            } else if (e.key === 'n' || e.key === 'N') {
                e.preventDefault();
                handleChoiceClick('n', 'reject');
            } else if (e.key === 'Escape') {
                e.preventDefault();
                submitChoicePrompt('no', '');
            }
        });

        function updateChoiceSelection() {
            if (!pendingConfirmation) return;
            const container = document.getElementById(`choices-${pendingConfirmation.messageId}`);
            if (!container) return;

            container.querySelectorAll('.choice-item').forEach((item, i) => {
                const isActive = i === selectedChoiceIndex;
                item.classList.toggle('choice-active', isActive);
                item.querySelector('.choice-marker').textContent = isActive ? '>' : ' ';
            });
        }

        async function confirmChoice(index) {
            if (!pendingConfirmation) return;

            const choice = pendingConfirmation.choices[index !== undefined ? index : selectedChoiceIndex];
            const messageId = pendingConfirmation.messageId;

            const container = document.getElementById(`choices-${messageId}`);
            if (container) {
                container.innerHTML = `<div style="color:var(--accent-green)">‚úì Selected: ${escapeHtml(choice.text)}</div>`;
            }

            try {
                const response = await fetch('/api/confirm', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message_id: messageId,
                        choice_id: choice.id,
                        choice_text: choice.text
                    })
                });

                const data = await response.json();
                if (data.success && data.response) {
                    addMessage('assistant', data.response);
                }
            } catch (e) {
                console.error('Confirmation error:', e);
            }

            pendingConfirmation = null;
        }

        // Global keyboard handler
        document.addEventListener('keydown', (e) => {
            // Escape to stop request
            if (e.key === 'Escape' && isProcessing && !pendingConfirmation) {
                e.preventDefault();
                stopRequest();
                return;
            }

            // Ctrl+O to expand all collapsed sections
            if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
                e.preventDefault();
                toggleAllCollapsed();
                return;
            }

            if (!pendingConfirmation) return;

            if (e.key === 'ArrowUp') {
                e.preventDefault();
                selectedChoiceIndex = Math.max(0, selectedChoiceIndex - 1);
                updateChoiceSelection();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                selectedChoiceIndex = Math.min(pendingConfirmation.choices.length - 1, selectedChoiceIndex + 1);
                updateChoiceSelection();
            } else if (e.key === 'Enter') {
                e.preventDefault();
                confirmChoice();
            } else if (e.key === 'Escape') {
                e.preventDefault();
                const container = document.getElementById(`choices-${pendingConfirmation.messageId}`);
                if (container) container.innerHTML = `<div style="color:var(--accent-red)">‚úó Cancelled</div>`;
                pendingConfirmation = null;
            } else if (e.key >= '1' && e.key <= '9') {
                const idx = parseInt(e.key) - 1;
                if (idx < pendingConfirmation.choices.length) {
                    e.preventDefault();
                    confirmChoice(idx);
                }
            }
        });

        // ========== MODEL SELECTOR ==========
        const modelSelector = document.getElementById('model-selector');
        const modelBadgeBtn = document.getElementById('model-badge');
        const modelDropdown = document.getElementById('model-dropdown');
        const modelList = document.getElementById('model-list');
        const modelNameSpan = document.getElementById('model-name');

        let availableModels = [];

        modelBadgeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const isOpen = modelSelector.classList.toggle('open');
            if (isOpen) loadModels();
        });

        document.addEventListener('click', (e) => {
            if (!modelSelector.contains(e.target)) {
                modelSelector.classList.remove('open');
            }
        });

        async function loadModels() {
            modelList.innerHTML = '<div class="model-dropdown-loading">Loading...</div>';
            try {
                const r = await fetch('/api/models');
                const data = await r.json();
                availableModels = data.models || [];
                const current = data.current || '';

                if (availableModels.length === 0) {
                    modelList.innerHTML = '<div class="model-dropdown-loading">No models found</div>';
                    return;
                }

                // Group by provider
                const ollama = availableModels.filter(m => m.provider === 'ollama');
                const claude = availableModels.filter(m => m.provider === 'anthropic');

                let html = '';

                if (ollama.length > 0) {
                    html += '<div class="model-dropdown-header">üñ•Ô∏è Ollama (Local)</div>';
                    html += ollama.map(m => renderModelItem(m, current)).join('');
                }

                if (claude.length > 0) {
                    html += '<div class="model-dropdown-header">‚òÅÔ∏è Claude (Anthropic API)</div>';
                    html += claude.map(m => renderModelItem(m, current)).join('');
                }

                modelList.innerHTML = html;
            } catch (e) {
                modelList.innerHTML = '<div class="model-dropdown-loading">Failed to load models</div>';
            }
        }

        function renderModelItem(m, current) {
            const isActive = m.name === current;
            const sizeMB = m.size ? (m.size / 1024 / 1024 / 1024).toFixed(1) + ' GB' : '';
            const params = m.params || '';
            const providerIcon = m.provider === 'anthropic' ? '‚òÅÔ∏è' : '';
            const meta = [params, sizeMB].filter(Boolean).join(' ‚Ä¢ ');
            const escapedName = m.name.replace(/'/g, "\\'");
            return `
                <div class="model-item ${isActive ? 'active' : ''}"
                     data-model="${m.name}"
                     onclick="selectModel('${escapedName}')">
                    <span class="model-item-check">${isActive ? '‚úì' : providerIcon}</span>
                    <div class="model-item-info">
                        <div class="model-item-name">${m.name}</div>
                        ${meta ? `<div class="model-item-meta">${meta}</div>` : ''}
                    </div>
                </div>
            `;
        }

        async function selectModel(name) {
            modelSelector.classList.remove('open');

            try {
                const r = await fetch('/api/models/switch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model: name })
                });
                const data = await r.json();

                if (data.success) {
                    modelNameSpan.textContent = name.split(':')[0];
                    addMessage('system', `Model switched: ${data.old_model} ‚Üí ${data.new_model}`);
                }
            } catch (e) {
                addMessage('system', `Failed to switch model: ${e.message}`);
            }
        }

        // ========== FULLSCREEN API ==========
        const fullscreenBtn = document.getElementById('fullscreen-btn');

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(() => {});
            } else {
                document.exitFullscreen();
            }
        }

        fullscreenBtn.addEventListener('click', toggleFullscreen);

        document.addEventListener('fullscreenchange', () => {
            const isFS = !!document.fullscreenElement;
            fullscreenBtn.textContent = isFS ? '\u2716' : '\u26F6';
            fullscreenBtn.title = isFS ? 'Exit fullscreen (F11)' : 'Toggle fullscreen (F11)';
            document.body.classList.toggle('compact-mode', isFS);
        });

        // F11 override ‚Äî use Fullscreen API instead of browser default
        document.addEventListener('keydown', (e) => {
            if (e.key === 'F11') {
                e.preventDefault();
                toggleFullscreen();
            }
        });

        // ========== PWA INSTALL ==========
        const installBtn = document.getElementById('install-btn');
        let deferredPrompt = null;

        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            installBtn.style.display = 'flex';
        });

        installBtn.addEventListener('click', async () => {
            if (!deferredPrompt) return;
            deferredPrompt.prompt();
            const result = await deferredPrompt.userChoice;
            if (result.outcome === 'accepted') {
                installBtn.style.display = 'none';
            }
            deferredPrompt = null;
        });

        window.addEventListener('appinstalled', () => {
            installBtn.style.display = 'none';
            deferredPrompt = null;
        });

        // ========== SERVICE WORKER REGISTRATION ==========
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/service-worker.js').catch(() => {});
        }

        // ========== STANDALONE DETECTION ==========
        if (window.matchMedia('(display-mode: standalone)').matches ||
            window.navigator.standalone === true) {
            document.body.classList.add('compact-mode');
        }

        // Focus input
        input.focus();

        // Auto-test: localhost:5002?test=multiline
        (async function autoTest() {
            const params = new URLSearchParams(window.location.search);
            const testType = params.get('test');
            if (testType === 'multiline' || testType === 'nested') {
                // Nested indentation test: replace 4-level deep block (lines 22-31)
                const oldStr = testType === 'nested'
                    ? "                    if check[\"type\"] == \"http\":\n                        container[\"health\"] = {\n                            \"endpoint\": check[\"path\"],\n                            \"interval\": 30\n                        }\n                    elif check[\"type\"] == \"tcp\":\n                        container[\"health\"] = {\n                            \"port\": check[\"port\"],\n                            \"timeout\": 10\n                        }"
                    : "def hello():\n    \"\"\"Say hello\"\"\"\n    print(\"Hello World\")\n    return True";
                const newStr = testType === 'nested'
                    ? "                    if check[\"type\"] == \"http\":\n                        container[\"health\"] = {\n                            \"endpoint\": check[\"path\"],\n                            \"interval\": check.get(\"interval\", 30),\n                            \"retries\": check.get(\"retries\", 3),\n                            \"timeout\": 5\n                        }\n                    elif check[\"type\"] == \"tcp\":\n                        container[\"health\"] = {\n                            \"port\": check[\"port\"],\n                            \"timeout\": check.get(\"timeout\", 10),\n                            \"retries\": 3\n                        }\n                    elif check[\"type\"] == \"exec\":\n                        container[\"health\"] = {\n                            \"command\": check[\"cmd\"],\n                            \"interval\": 60\n                        }"
                    : "def hello(name=\"World\"):\n    \"\"\"Say hello to someone\"\"\"\n    greeting = f\"Hello {name}\"\n    print(greeting)\n    return greeting";
                const label = testType === 'nested'
                    ? 'nested edit: replace health_check block (10 lines ‚Üí 18 lines, 4-level indent)'
                    : 'multiline edit: replace hello() function (4‚Üí5 lines)';
                addMessage('user', label);
                const loadId = showLoading('Running edit test...');
                try {
                    const r = await fetch('/api/test-multiline-edit', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            file_path: '_test_diff.py',
                            old_string: oldStr,
                            new_string: newStr
                        })
                    });
                    const d = await r.json();
                    hideLoading(loadId);
                    if (d.tool_calls) {
                        for (const tc of d.tool_calls) addToolCall(tc);
                    }
                    // Scroll diff container to top so full diff is visible
                    setTimeout(() => {
                        const dc = document.querySelector('.diff-content');
                        if (dc) dc.scrollTop = 0;
                        window.scrollTo(0, 0);
                    }, 200);
                } catch(e) {
                    hideLoading(loadId);
                    addMessage('system', 'Test error: ' + e.message);
                }
            }
        })();
    </script>
</body>
</html>
